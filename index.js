'use strict';

const pbkdf2 = require('pbkdf2-crypt');

/**
 * Default configurations used to generate a new hash.
 * @private
 * @type {Object}
 */
const defaultConfigs = {
  // Minimum number of iterations recommended to ensure data safety,
  // this value changes every year as technology improves.
  iterations: 10000,

  // According to the PBKDF2 standard, the minimum recommended size is 64 bytes.
  keylen: 64,

  // SHA-1 is sufficient however, using SHA-256 or SHA-512 has the benefit of
  // significantly increasing the memory requirements, which increases the cost
  // for an attacker wishing to attack use hardware-based password crackers
  // based on GPUs or ASICs.
  digest: 'sha256',
};

/**
 * Applies the hashing algorithm to the provided password.
 * @public
 * @param  {string} password The password to hash.
 * @param  {Object} [options] Configurations passed to the hashing function.
 * @param  {number} [options.iterations] The number of iterations to compute the
 * derived key.
 * @param  {number} [options.keylen] The length of the computed derived key.
 * @param  {number} [options.digest] A digest function from the
 * crypto.getHashes() list of supported digest functions.
 * @return {Promise.<string>} The generated hash string.
 */
function hash(password, options) {
  if (typeof password !== 'string' || password.length === 0) {
    return Promise.reject(
      new TypeError('Password must be a non-empty string.')
    );
  }
  if (options !== undefined && typeof options !== 'object') {
    return Promise.reject(new TypeError('Options must be an object.'));
  }

  const cfgs = Object.assign(defaultConfigs, options);

  return pbkdf2.hash(password, cfgs);
}

/**
 * Determines whether the user's input matches the stored password or not.
 * @public
 * @param  {string} hash The hash string generated by this package.
 * @param  {string} password The user's password input.
 * @return {Promise.<boolean>} A boolean that is true if the hash computed for
 * the password matches the provided hash.
 */
function verify(hash, password) {
  if (typeof hash !== 'string' || hash.length === 0) {
    return Promise.reject(new TypeError('Hash must be a non-empty string.'));
  }
  if (typeof password !== 'string' || password.length === 0) {
    return Promise.reject(
      new TypeError('Password must be a non-empty string.')
    );
  }

  return pbkdf2.verify(hash, password);
}

module.exports = {
  hash,
  verify,
};
